import sys
import os
import datetime
import sqlite3
from PyQt5.QtWidgets import (QApplication, QMainWindow, QTabWidget, QWidget, 
                            QVBoxLayout, QHBoxLayout, QLabel, QPushButton, 
                            QTableWidget, QTableWidgetItem, QComboBox, QSlider,
                            QFileDialog, QMessageBox, QProgressBar)
from PyQt5.QtCore import Qt, QTimer, pyqtSignal, QThread, QDateTime
from PyQt5.QtGui import QImage, QPixmap, QFont, QColor
import pyqtgraph as pg
from datetime import datetime, timedelta
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# For video display
import cv2
import numpy as np
from PIL import Image

# Import our existing analysis modules
from tracking import detect_human
from yolov8_detector import YOLOv8Detector
from deep_sort import nn_matching
from deep_sort.detection import Detection
from deep_sort.tracker import Tracker
from deep_sort import generate_detections as gdet
from util import kinetic_energy

class AdminDashboard(QMainWindow):
    def __init__(self):
        super().__init__()
        
        # Dashboard title and size
        self.setWindowTitle("Crowd Analysis Admin Dashboard")
        self.setGeometry(100, 100, 1280, 720)
        
        # Initialize the UI
        self.init_ui()
        
        # Initialize database
        self.init_database()
        
        # Start with video processing stopped
        self.is_processing = False
        self.is_recording = False
        
        # Status update timer
        self.status_timer = QTimer(self)
        self.status_timer.timeout.connect(self.update_status)
        self.status_timer.start(5000)  # Update every 5 seconds
        
    def init_ui(self):
        # Create central widget and main layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        
        # Create tab widget for different sections
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)
        
        # Create tabs
        self.monitoring_tab = self.create_monitoring_tab()
        self.alerts_tab = self.create_alerts_tab()
        self.analytics_tab = self.create_analytics_tab()
        self.settings_tab = self.create_settings_tab()
        
        # Add tabs to widget
        self.tabs.addTab(self.monitoring_tab, "Monitoring")
        self.tabs.addTab(self.alerts_tab, "Alerts")
        self.tabs.addTab(self.analytics_tab, "Analytics")
        self.tabs.addTab(self.settings_tab, "Settings")
        
        # Status bar for dashboard information
        self.statusBar().showMessage("Dashboard Ready")
        
    def create_monitoring_tab(self):
        # Tab for video monitoring
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Video feed display
        self.video_label = QLabel()
        self.video_label.setAlignment(Qt.AlignCenter)
        self.video_label.setText("No Video Feed")
        self.video_label.setStyleSheet("background-color: black; color: white;")
        layout.addWidget(self.video_label)
        
        # Controls layout
        controls_layout = QHBoxLayout()
        
        # Video source selection
        self.video_source_combo = QComboBox()
        self.video_source_combo.addItem("Select Video Source")
        self.video_source_combo.addItem("Webcam")
        self.video_source_combo.addItem("Browse...")
        self.video_source_combo.currentIndexChanged.connect(self.handle_video_source_change)
        controls_layout.addWidget(self.video_source_combo)
        
        # Start/Stop button
        self.start_stop_button = QPushButton("Start Processing")
        self.start_stop_button.clicked.connect(self.toggle_processing)
        controls_layout.addWidget(self.start_stop_button)
        
        layout.addLayout(controls_layout)
        
        # View controls
        view_controls = QHBoxLayout()
        view_controls.addWidget(QLabel("View Mode:"))
        self.view_mode_combo = QComboBox()
        self.view_mode_combo.addItems(["Normal", "Heatmap", "Flow Tracking"])
        self.view_mode_combo.currentIndexChanged.connect(self.handle_view_mode_change)
        view_controls.addWidget(self.view_mode_combo)
        
        layout.addLayout(view_controls)
        
        # Current stats display
        stats_layout = QHBoxLayout()
        
        self.crowd_count_label = QLabel("Crowd Count: 0")
        self.crowd_count_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        self.violation_count_label = QLabel("Violations: 0")
        self.violation_count_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        self.abnormal_activity_label = QLabel("Abnormal Activity: None")
        self.abnormal_activity_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        
        stats_layout.addWidget(self.crowd_count_label)
        stats_layout.addWidget(self.violation_count_label)
        stats_layout.addWidget(self.abnormal_activity_label)
        
        layout.addLayout(stats_layout)
        
        # Add processing status indicator
        self.processing_status = QLabel("Processing Status: Idle")
        self.processing_status.setStyleSheet("font-style: italic;")
        layout.addWidget(self.processing_status)
        
        # Add FPS counter
        self.fps_counter = QLabel("FPS: --")
        layout.addWidget(self.fps_counter)
        
        # Add recording controls
        recording_layout = QHBoxLayout()
        
        self.record_button = QPushButton("Start Recording")
        self.record_button.clicked.connect(self.toggle_recording)
        self.record_button.setEnabled(False)  # Disabled until processing starts
        recording_layout.addWidget(self.record_button)
        
        self.recording_status = QLabel("Recording: Off")
        recording_layout.addWidget(self.recording_status)
        
        # Add recording progress bar
        self.recording_progress = QProgressBar()
        self.recording_progress.setRange(0, 100)
        self.recording_progress.setValue(0)
        self.recording_progress.setVisible(False)
        recording_layout.addWidget(self.recording_progress)
        
        layout.addLayout(recording_layout)
        
        return tab
    
    def create_alerts_tab(self):
        # Tab for alerts and notifications
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Alert log table
        self.alert_table = QTableWidget()
        self.alert_table.setColumnCount(4)
        self.alert_table.setHorizontalHeaderLabels(["Time", "Type", "Severity", "Description"])
        self.alert_table.horizontalHeader().setStretchLastSection(True)
        self.alert_table.setSortingEnabled(True)  # Enable sorting
        layout.addWidget(self.alert_table)
        
        # Alert controls
        alert_controls = QHBoxLayout()
        
        self.clear_alerts_button = QPushButton("Clear Alerts")
        self.clear_alerts_button.clicked.connect(self.clear_alerts)
        
        self.export_alerts_button = QPushButton("Export Alerts")
        self.export_alerts_button.clicked.connect(self.export_alerts)
        
        self.test_alert_button = QPushButton("Generate Test Alert")
        self.test_alert_button.clicked.connect(self.generate_test_alert)
        
        alert_controls.addWidget(self.clear_alerts_button)
        alert_controls.addWidget(self.export_alerts_button)
        alert_controls.addWidget(self.test_alert_button)
        
        layout.addLayout(alert_controls)
        
        # Add filter controls
        filter_layout = QHBoxLayout()
        
        filter_layout.addWidget(QLabel("Filter by Severity:"))
        self.severity_filter = QComboBox()
        self.severity_filter.addItems(["All", "Low", "Medium", "Critical"])
        self.severity_filter.currentIndexChanged.connect(self.filter_alerts)
        filter_layout.addWidget(self.severity_filter)
        
        filter_layout.addWidget(QLabel("Filter by Type:"))
        self.type_filter = QComboBox()
        self.type_filter.addItems(["All", "Abnormal Activity", "Social Distance", "High Crowd Density", "System"])
        self.type_filter.currentIndexChanged.connect(self.filter_alerts)
        filter_layout.addWidget(self.type_filter)
        
        layout.addLayout(filter_layout)
        
        # Alert statistics
        stats_layout = QHBoxLayout()
        
        self.alert_count_label = QLabel("Total Alerts: 0")
        self.critical_count_label = QLabel("Critical Alerts: 0")
        
        stats_layout.addWidget(self.alert_count_label)
        stats_layout.addWidget(self.critical_count_label)
        
        layout.addLayout(stats_layout)
        
        return tab
    
    def create_analytics_tab(self):
        # Tab for analytics visualization
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Time range selection
        time_controls = QHBoxLayout()
        time_controls.addWidget(QLabel("Time Range:"))
        self.time_range_combo = QComboBox()
        self.time_range_combo.addItems(["Last Hour", "Last Day", "Last Week", "All Data"])
        self.time_range_combo.currentIndexChanged.connect(self.update_analytics)
        time_controls.addWidget(self.time_range_combo)
        
        layout.addLayout(time_controls)
        
        # Create plots
        plots_layout = QHBoxLayout()
        
        # Crowd count plot
        self.crowd_plot_widget = pg.PlotWidget(title="Crowd Count Over Time")
        self.crowd_plot_widget.setLabel('left', 'Count')
        self.crowd_plot_widget.setLabel('bottom', 'Time')
        self.crowd_plot_widget.showGrid(x=True, y=True)
        plots_layout.addWidget(self.crowd_plot_widget)
        
        # Violation count plot
        self.violation_plot_widget = pg.PlotWidget(title="Violations Over Time")
        self.violation_plot_widget.setLabel('left', 'Count')
        self.violation_plot_widget.setLabel('bottom', 'Time')
        self.violation_plot_widget.showGrid(x=True, y=True)
        plots_layout.addWidget(self.violation_plot_widget)
        
        layout.addLayout(plots_layout)
        
        # Second row of plots
        plots_layout2 = QHBoxLayout()
        
        # Abnormal events plot
        self.abnormal_plot_widget = pg.PlotWidget(title="Abnormal Activity Events")
        self.abnormal_plot_widget.setLabel('left', 'Events')
        self.abnormal_plot_widget.setLabel('bottom', 'Time')
        self.abnormal_plot_widget.showGrid(x=True, y=True)
        plots_layout2.addWidget(self.abnormal_plot_widget)
        
        # Stats summary widget
        self.stats_summary = QTableWidget()
        self.stats_summary.setColumnCount(2)
        self.stats_summary.setRowCount(5)
        self.stats_summary.setHorizontalHeaderLabels(["Metric", "Value"])
        self.stats_summary.horizontalHeader().setStretchLastSection(True)
        self.stats_summary.setItem(0, 0, QTableWidgetItem("Peak Crowd Count"))
        self.stats_summary.setItem(1, 0, QTableWidgetItem("Average Crowd Count"))
        self.stats_summary.setItem(2, 0, QTableWidgetItem("Total Violations"))
        self.stats_summary.setItem(3, 0, QTableWidgetItem("Abnormal Events"))
        self.stats_summary.setItem(4, 0, QTableWidgetItem("Alert Count"))
        plots_layout2.addWidget(self.stats_summary)
        
        layout.addLayout(plots_layout2)
        
        # Control buttons
        controls_layout = QHBoxLayout()
        
        refresh_button = QPushButton("Refresh Data")
        refresh_button.clicked.connect(self.update_analytics)
        
        export_button = QPushButton("Export Analytics Data")
        export_button.clicked.connect(self.export_analytics)
        
        controls_layout.addWidget(refresh_button)
        controls_layout.addWidget(export_button)
        
        layout.addLayout(controls_layout)
        
        return tab
    
    def create_settings_tab(self):
        # Tab for dashboard settings
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Detection thresholds
        thresholds_group = QWidget()
        thresholds_layout = QVBoxLayout(thresholds_group)
        
        thresholds_layout.addWidget(QLabel("<b>Detection Thresholds</b>"))
        
        # Social distance threshold
        social_dist_layout = QHBoxLayout()
        social_dist_layout.addWidget(QLabel("Social Distance Threshold:"))
        self.social_distance_slider = QSlider(Qt.Horizontal)
        self.social_distance_slider.setRange(30, 150)
        self.social_distance_slider.setValue(50)
        self.social_distance_slider.valueChanged.connect(self.update_settings)
        self.social_distance_value = QLabel("50 px")
        social_dist_layout.addWidget(self.social_distance_slider)
        social_dist_layout.addWidget(self.social_distance_value)
        thresholds_layout.addLayout(social_dist_layout)
        
        # Abnormal energy threshold
        energy_layout = QHBoxLayout()
        energy_layout.addWidget(QLabel("Abnormal Energy Threshold:"))
        self.energy_slider = QSlider(Qt.Horizontal)
        self.energy_slider.setRange(500, 5000)
        self.energy_slider.setValue(1866)
        self.energy_slider.valueChanged.connect(self.update_settings)
        self.energy_value = QLabel("1866")
        energy_layout.addWidget(self.energy_slider)
        energy_layout.addWidget(self.energy_value)
        thresholds_layout.addLayout(energy_layout)
        
        # Abnormal threshold ratio
        abnormal_ratio_layout = QHBoxLayout()
        abnormal_ratio_layout.addWidget(QLabel("Abnormal Activity Ratio:"))
        self.abnormal_ratio_slider = QSlider(Qt.Horizontal)
        self.abnormal_ratio_slider.setRange(1, 100)
        self.abnormal_ratio_slider.setValue(66)  # 0.66 * 100
        self.abnormal_ratio_slider.valueChanged.connect(self.update_settings)
        self.abnormal_ratio_value = QLabel("0.66")
        abnormal_ratio_layout.addWidget(self.abnormal_ratio_slider)
        abnormal_ratio_layout.addWidget(self.abnormal_ratio_value)
        thresholds_layout.addLayout(abnormal_ratio_layout)
        
        layout.addWidget(thresholds_group)
        
        # Notification settings
        notification_group = QWidget()
        notification_layout = QVBoxLayout(notification_group)
        
        notification_layout.addWidget(QLabel("<b>Notification Settings</b>"))
        
        # Email notifications
        email_layout = QHBoxLayout()
        email_layout.addWidget(QLabel("Email Notifications:"))
        self.email_combo = QComboBox()
        self.email_combo.addItems(["Disabled", "Critical Only", "All Alerts"])
        email_layout.addWidget(self.email_combo)
        notification_layout.addLayout(email_layout)
        
        # Email address
        email_address_layout = QHBoxLayout()
        email_address_layout.addWidget(QLabel("Email Address:"))
        self.email_address_input = QComboBox()
        self.email_address_input.setEditable(True)
        email_address_layout.addWidget(self.email_address_input)
        notification_layout.addLayout(email_address_layout)
        
        # Desktop notifications
        desktop_layout = QHBoxLayout()
        desktop_layout.addWidget(QLabel("Desktop Notifications:"))
        self.desktop_combo = QComboBox()
        self.desktop_combo.addItems(["Disabled", "Critical Only", "All Alerts"])
        desktop_layout.addWidget(self.desktop_combo)
        notification_layout.addLayout(desktop_layout)
        
        layout.addWidget(notification_group)
        
        # Performance settings
        performance_group = QWidget()
        performance_layout = QVBoxLayout(performance_group)
        
        performance_layout.addWidget(QLabel("<b>Performance Settings</b>"))
        
        # Processing frame skip
        frame_skip_layout = QHBoxLayout()
        frame_skip_layout.addWidget(QLabel("Frame Skip:"))
        self.frame_skip_slider = QSlider(Qt.Horizontal)
        self.frame_skip_slider.setRange(1, 10)
        self.frame_skip_slider.setValue(2)
        self.frame_skip_slider.valueChanged.connect(self.update_settings)
        self.frame_skip_value = QLabel("2 frames")
        frame_skip_layout.addWidget(self.frame_skip_slider)
        frame_skip_layout.addWidget(self.frame_skip_value)
        performance_layout.addLayout(frame_skip_layout)
        
        # Processing resolution
        resolution_layout = QHBoxLayout()
        resolution_layout.addWidget(QLabel("Processing Resolution:"))
        self.resolution_combo = QComboBox()
        self.resolution_combo.addItems(["320x240", "640x480", "800x600", "1280x720"])
        self.resolution_combo.setCurrentText("640x480")
        resolution_layout.addWidget(self.resolution_combo)
        performance_layout.addLayout(resolution_layout)
        
        layout.addWidget(performance_group)
        
        # Save settings button
        self.save_settings_button = QPushButton("Save Settings")
        self.save_settings_button.clicked.connect(self.save_settings)
        layout.addWidget(self.save_settings_button)
        
        return tab
    
    def init_database(self):
        # Initialize SQLite database for storing alerts and settings
        db_path = "dashboard.db"
        self.conn = sqlite3.connect(db_path)
        self.cursor = self.conn.cursor()
        
        # Create alerts table if it doesn't exist
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS alerts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
            type TEXT,
            severity INTEGER,
            description TEXT
        )
        ''')
        
        # Create settings table if it doesn't exist
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS settings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT UNIQUE,
            value TEXT
        )
        ''')
        
        # Create video_sources table if it doesn't exist
        self.cursor.execute('''
        CREATE TABLE IF NOT EXISTS video_sources (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            path TEXT,
            last_used DATETIME
        )
        ''')
        
        # Save changes
        self.conn.commit()
        
        # Load settings
        self.load_settings()
        
        # Load saved videos
        self.load_video_sources()
        
        # Update alerts table
        self.update_alerts_table()
    
    def load_settings(self):
        # Load settings from database
        self.cursor.execute("SELECT name, value FROM settings")
        settings = dict(self.cursor.fetchall())
        
        # Apply settings to UI elements if they exist
        if 'social_distance' in settings:
            self.social_distance_slider.setValue(int(settings['social_distance']))
        if 'abnormal_energy' in settings:
            self.energy_slider.setValue(int(settings['abnormal_energy']))
        if 'abnormal_ratio' in settings:
            self.abnormal_ratio_slider.setValue(int(float(settings['abnormal_ratio']) * 100))
        if 'email_notifications' in settings:
            self.email_combo.setCurrentText(settings['email_notifications'])
        if 'desktop_notifications' in settings:
            self.desktop_combo.setCurrentText(settings['desktop_notifications'])
        if 'frame_skip' in settings:
            self.frame_skip_slider.setValue(int(settings['frame_skip']))
        if 'resolution' in settings:
            self.resolution_combo.setCurrentText(settings['resolution'])
        if 'email_address' in settings:
            self.email_address_input.setEditText(settings['email_address'])
    
    def load_video_sources(self):
        # Load saved video sources
        self.cursor.execute("SELECT name, path FROM video_sources ORDER BY last_used DESC")
        sources = self.cursor.fetchall()
        
        # Add to combo box
        for name, path in sources:
            self.video_source_combo.addItem(f"File: {name}")
    
    def update_settings(self):
        # Update settings labels when sliders change
        self.social_distance_value.setText(f"{self.social_distance_slider.value()} px")
        self.energy_value.setText(str(self.energy_slider.value()))
        self.abnormal_ratio_value.setText(str(self.abnormal_ratio_slider.value() / 100))
        self.frame_skip_value.setText(f"{self.frame_skip_slider.value()} frames")
    
    def save_settings(self):
        # Save settings to database
        settings = [
            ('social_distance', str(self.social_distance_slider.value())),
            ('abnormal_energy', str(self.energy_slider.value())),
            ('abnormal_ratio', str(self.abnormal_ratio_slider.value() / 100)),
            ('email_notifications', self.email_combo.currentText()),
            ('desktop_notifications', self.desktop_combo.currentText()),
            ('frame_skip', str(self.frame_skip_slider.value())),
            ('resolution', self.resolution_combo.currentText()),
            ('email_address', self.email_address_input.currentText())
        ]
        
        # Update or insert settings
        for name, value in settings:
            self.cursor.execute(
                "INSERT OR REPLACE INTO settings (name, value) VALUES (?, ?)",
                (name, value)
            )
        
        # Save changes
        self.conn.commit()
        self.statusBar().showMessage("Settings saved", 3000)
        
        # If processing is active, update the thread settings
        if hasattr(self, 'video_thread') and self.video_thread.isRunning():
            self.video_thread.social_distance = self.social_distance_slider.value()
            self.video_thread.abnormal_energy = self.energy_slider.value()
            self.video_thread.abnormal_thresh = self.abnormal_ratio_slider.value() / 100
            self.video_thread.frame_skip = self.frame_skip_slider.value()
            
            # Resolution needs special handling - requires restart
            new_resolution = self.resolution_combo.currentText()
            if new_resolution != self.video_thread.resolution:
                QMessageBox.information(self, "Resolution Changed", 
                    "The resolution change will take effect the next time processing is started.")
    
    def handle_video_source_change(self):
        # Handle video source selection
        source = self.video_source_combo.currentText()
        if source == "Webcam":
            self.video_source = 0  # Default camera
        elif source == "Browse...":
            # Open file dialog
            file_path, _ = QFileDialog.getOpenFileName(
                self, "Select Video File", "", "Video Files (*.mp4 *.avi *.mov *.mkv);;All Files (*)"
            )
            
            if file_path:
                self.video_source = file_path
                file_name = os.path.basename(file_path)
                
                # Save to database
                self.cursor.execute(
                    "INSERT INTO video_sources (name, path, last_used) VALUES (?, ?, datetime('now'))",
                    (file_name, file_path)
                )
                self.conn.commit()
                
                # Add to dropdown
                self.video_source_combo.removeItem(self.video_source_combo.currentIndex())
                self.video_source_combo.addItem(f"File: {file_name}")
                self.video_source_combo.setCurrentIndex(self.video_source_combo.count() - 1)
            else:
                # User canceled file selection
                self.video_source_combo.setCurrentIndex(0)
                self.video_source = None
        else:
            if source.startswith("File: "):
                # Extract saved file path
                file_name = source.replace("File: ", "")
                # Look up the full path from database
                self.cursor.execute(
                    "SELECT path FROM video_sources WHERE name = ?", 
                    (file_name,)
                )
                result = self.cursor.fetchone()
                if result:
                    self.video_source = result[0]
                    
                    # Update last used time
                    self.cursor.execute(
                        "UPDATE video_sources SET last_used = datetime('now') WHERE name = ?",
                        (file_name,)
                    )
                    self.conn.commit()
                else:
                    self.video_source = None
                    self.statusBar().showMessage("Video file path not found", 3000)
            else:
                self.video_source = None
    
    def handle_view_mode_change(self):
        if hasattr(self, 'video_thread'):
            mode = self.view_mode_combo.currentText()
            self.video_thread.view_mode = mode
            self.statusBar().showMessage(f"View mode changed to {mode}", 3000)
    
    def toggle_processing(self):
        # Toggle video processing
        if not self.is_processing:
            if not hasattr(self, 'video_source') or self.video_source is None:
                self.statusBar().showMessage("Please select a video source", 3000)
                return
            
            # Start processing
            self.start_processing()
            self.start_stop_button.setText("Stop Processing")
            self.is_processing = True
            self.record_button.setEnabled(True)  # Enable recording
        else:
            # Stop processing
            self.stop_processing()
            self.start_stop_button.setText("Start Processing")
            self.is_processing = False
            self.record_button.setEnabled(False)  # Disable recording
            
            # If recording, stop it
            if self.is_recording:
                self.stop_recording()
    
    def start_processing(self):
        # Get resolution from settings
        resolution_text = self.resolution_combo.currentText()
        width, height = map(int, resolution_text.split('x'))
        
        # Initialize video processing thread
        self.video_thread = VideoProcessingThread(
            self.video_source, 
            width=width, 
            height=height,
            frame_skip=self.frame_skip_slider.value(),
            social_distance=self.social_distance_slider.value(),
            abnormal_energy=self.energy_slider.value(),
            abnormal_thresh=self.abnormal_ratio_slider.value() / 100
        )
        self.video_thread.frame_update.connect(self.update_video_frame)
        self.video_thread.stats_update.connect(self.update_stats)
        self.video_thread.alert_triggered.connect(self.handle_alert)
        self.video_thread.fps_update.connect(self.update_fps)
        self.video_thread.start()
        
        self.statusBar().showMessage("Video processing started")
        self.processing_status.setText("Processing Status: Active")
    
    def stop_processing(self):
        # Stop video processing thread
        if hasattr(self, 'video_thread') and self.video_thread.isRunning():
            self.video_thread.stop()
            self.video_thread.wait()
        
        self.statusBar().showMessage("Video processing stopped")
        self.processing_status.setText("Processing Status: Idle")
        self.fps_counter.setText("FPS: --")
    
    def update_video_frame(self, frame):
        # Update video display with processed frame
        h, w, ch = frame.shape
        img = QImage(frame.data, w, h, ch * w, QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(img)
        self.video_label.setPixmap(pixmap.scaled(self.video_label.size(), Qt.KeepAspectRatio))
    
    def update_fps(self, fps):
        # Update FPS counter
        self.fps_counter.setText(f"FPS: {fps:.1f}")
    
    def update_stats(self, crowd_count, violation_count, abnormal_activity):
        # Update dashboard statistics
        self.crowd_count_label.setText(f"Crowd Count: {crowd_count}")
        self.violation_count_label.setText(f"Violations: {violation_count}")
        
        if abnormal_activity:
            self.abnormal_activity_label.setText("Abnormal Activity: Detected")
            self.abnormal_activity_label.setStyleSheet("color: red; font-weight: bold;")
        else:
            self.abnormal_activity_label.setText("Abnormal Activity: None")
            self.abnormal_activity_label.setStyleSheet("font-size: 14px; font-weight: bold;")
    
    def handle_alert(self, alert_type, severity, description):
        # Handle new alert
        # Add to database
        self.cursor.execute(
            "INSERT INTO alerts (type, severity, description) VALUES (?, ?, ?)",
            (alert_type, severity, description)
        )
        self.conn.commit()
        
        # Update alerts table
        self.update_alerts_table()
        
        # Show notifications if needed
        self.show_notifications(alert_type, severity, description)
    
    def show_notifications(self, alert_type, severity, description):
        # Email notifications
        email_setting = self.email_combo.currentText()
        if (email_setting == "All Alerts" or 
            (email_setting == "Critical Only" and severity >= 3)):
            self.send_email_alert(alert_type, description)
        
        # Desktop notifications
        desktop_setting = self.desktop_combo.currentText()
        if (desktop_setting == "All Alerts" or 
            (desktop_setting == "Critical Only" and severity >= 3)):
            self.show_desktop_notification(alert_type, description)
    
    def update_alerts_table(self):
        # Update the alerts table with data from database
        
        # Apply filters
        severity_filter = self.severity_filter.currentText()
        type_filter = self.type_filter.currentText()
        
        query = "SELECT timestamp, type, severity, description FROM alerts WHERE 1=1"
        params = []
        
        # Apply severity filter
        if severity_filter != "All":
            if severity_filter == "Low":
                query += " AND severity = 1"
            elif severity_filter == "Medium":
                query += " AND severity = 2"
            elif severity_filter == "Critical":
                query += " AND severity = 3"
        
        # Apply type filter
        if type_filter != "All":
            query += " AND type = ?"
            params.append(type_filter)
        
        # Order by most recent
        query += " ORDER BY timestamp DESC LIMIT 100"
        
        self.cursor.execute(query, params)
        alerts = self.cursor.fetchall()
        
        # Set row count
        self.alert_table.setRowCount(len(alerts))
        
        # Populate table
        for row, (timestamp, alert_type, severity, description) in enumerate(alerts):
            # Format timestamp
            time_item = QTableWidgetItem(timestamp)
            type_item = QTableWidgetItem(alert_type)
            severity_item = QTableWidgetItem(str(severity))
            description_item = QTableWidgetItem(description)
            
            # Color code by severity
            if severity >= 3:  # Critical
                color = QColor(255, 0, 0, 100)  # Red
            elif severity == 2:  # High
                color = QColor(255, 165, 0, 100)  # Orange
            else:  # Low
                color = QColor(255, 255, 0, 50)  # Yellow
                
            type_item.setBackground(color)
            
            # Add items to table
            self.alert_table.setItem(row, 0, time_item)
            self.alert_table.setItem(row, 1, type_item)
            self.alert_table.setItem(row, 2, severity_item)
            self.alert_table.setItem(row, 3, description_item)
        
        # Update alert stats
        self.cursor.execute("SELECT COUNT(*) FROM alerts")
        total_count = self.cursor.fetchone()[0]
        self.alert_count_label.setText(f"Total Alerts: {total_count}")
        
        self.cursor.execute("SELECT COUNT(*) FROM alerts WHERE severity >= 3")
        critical_count = self.cursor.fetchone()[0]
        self.critical_count_label.setText(f"Critical Alerts: {critical_count}")
    
    def filter_alerts(self):
        # Trigger alerts table update when filters change
        self.update_alerts_table()
    
    def clear_alerts(self):
        # Ask for confirmation
        reply = QMessageBox.question(
            self, 'Confirm', 'Are you sure you want to clear all alerts?',
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Clear alerts from database and table
            self.cursor.execute("DELETE FROM alerts")
            self.conn.commit()
            self.alert_table.setRowCount(0)
            
            # Update alert stats
            self.alert_count_label.setText("Total Alerts: 0")
            self.critical_count_label.setText("Critical Alerts: 0")
            
            self.statusBar().showMessage("Alerts cleared", 3000)
    
    def export_alerts(self):
        # Export alerts to CSV
        filename, _ = QFileDialog.getSaveFileName(
            self, "Export Alerts", 
            f"alerts_export_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
            "CSV Files (*.csv);;All Files (*)"
        )
        
        if not filename:
            return
        
        try:
            with open(filename, 'w') as f:
                f.write("Timestamp,Type,Severity,Description\n")
                
                self.cursor.execute(
                    "SELECT timestamp, type, severity, description FROM alerts ORDER BY timestamp DESC"
                )
                
                for row in self.cursor.fetchall():
                    f.write(f"{row[0]},{row[1]},{row[2]},\"{row[3]}\"\n")
            
            self.statusBar().showMessage(f"Alerts exported to {filename}", 3000)
        except Exception as e:
            self.statusBar().showMessage(f"Export failed: {str(e)}", 3000)
    
    def generate_test_alert(self):
        # Generate a test alert
        alert_types = ["Social Distance Violations", "High Crowd Density", "Abnormal Crowd Activity", "System Notification"]
        severities = [1, 2, 3]
        
        import random
        alert_type = random.choice(alert_types)
        severity = random.choice(severities)
        description = f"This is a test alert of type {alert_type} with severity {severity}"
        
        self.handle_alert(alert_type, severity, description)
        self.statusBar().showMessage("Test alert generated", 3000)
    
    def update_analytics(self):
        try:
            # Get time range
            time_range = self.time_range_combo.currentText()
            
            # Calculate time filter
            now = datetime.datetime.now()
            if time_range == "Last Hour":
                time_filter = now - datetime.timedelta(hours=1)
            elif time_range == "Last Day":
                time_filter = now - datetime.timedelta(days=1)
            elif time_range == "Last Week":
                time_filter = now - datetime.timedelta(weeks=1)
            else:  # All Data
                time_filter = datetime.datetime.min
            
            # Load crowd data
            try:
                with open('processed_data/crowd_data.csv', 'r') as file:
                    lines = file.readlines()[1:]  # Skip header
                    
                    times = []
                    crowd_counts = []
                    violation_counts = []
                    abnormal_events = []
                    
                    for line in lines:
                        parts = line.strip().split(',')
                        if len(parts) >= 5:
                            # Parse time (handle both timestamp and frame number)
                            try:
                                if parts[0].isdigit():
                                    # Frame number - convert to a time point
                                    time_point = int(parts[0])
                                else:
                                    # Date string - convert to datetime
                                    time_point = datetime.datetime.strptime(parts[0], "%Y-%m-%d %H:%M:%S")
                                    # Skip if before filter
                                    if time_point < time_filter:
                                        continue
                            except:
                                continue
                                
                            # Extract data
                            crowd_count = int(parts[1])
                            violation_count = int(parts[2])
                            abnormal = bool(int(parts[4]))
                            
                            times.append(time_point)
                            crowd_counts.append(crowd_count)
                            violation_counts.append(violation_count)
                            abnormal_events.append(1 if abnormal else 0)
                    
                    # Update plots
                    if len(times) > 0:
                        # Clear previous plots
                        self.crowd_plot_widget.clear()
                        self.violation_plot_widget.clear()
                        self.abnormal_plot_widget.clear()
                        
                        # Create new plots
                        self.crowd_plot_widget.plot(times, crowd_counts, pen='g')
                        self.violation_plot_widget.plot(times, violation_counts, pen='y')
                        self.abnormal_plot_widget.plot(times, abnormal_events, pen='r', 
                                                      symbolBrush=(255,0,0), symbol='o', 
                                                      symbolPen='r')
                        
                        # Update summary stats
                        if crowd_counts:
                            self.stats_summary.setItem(0, 1, QTableWidgetItem(str(max(crowd_counts))))
                            self.stats_summary.setItem(1, 1, QTableWidgetItem(str(round(sum(crowd_counts)/len(crowd_counts), 1))))
                        else:
                            self.stats_summary.setItem(0, 1, QTableWidgetItem("0"))
                            self.stats_summary.setItem(1, 1, QTableWidgetItem("0"))
                            
                        self.stats_summary.setItem(2, 1, QTableWidgetItem(str(sum(violation_counts))))
                        self.stats_summary.setItem(3, 1, QTableWidgetItem(str(sum(abnormal_events))))
            except Exception as e:
                print(f"Error loading crowd data: {str(e)}")
                
            # Get alert count from database
            self.cursor.execute("SELECT COUNT(*) FROM alerts")
            alert_count = self.cursor.fetchone()[0]
            self.stats_summary.setItem(4, 1, QTableWidgetItem(str(alert_count)))
                
        except Exception as e:
            self.statusBar().showMessage(f"Error updating analytics: {str(e)}", 3000)
    
    def export_analytics(self):
        try:
            # Export as CSV
            filename, _ = QFileDialog.getSaveFileName(
                self, "Export Analytics", 
                f"analytics_export_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                "CSV Files (*.csv);;All Files (*)"
            )
            
            if not filename:
                return
                
            with open(filename, 'w') as f:
                f.write("Time,Crowd Count,Violations,Abnormal Activity\n")
                
                # Load crowd data
                with open('processed_data/crowd_data.csv', 'r') as data_file:
                    lines = data_file.readlines()[1:]  # Skip header
                    for line in lines:
                        f.write(line)
            
            self.statusBar().showMessage(f"Analytics exported to {filename}", 3000)
        except Exception as e:
            self.statusBar().showMessage(f"Export failed: {str(e)}", 3000)
    
    def send_email_alert(self, subject, message):
        # Check if email notifications are enabled
        email_setting = self.email_combo.currentText()
        if email_setting == "Disabled":
            return
            
        try:
            # Get email address from settings
            recipient = self.email_address_input.currentText()
            
            if not recipient:
                self.statusBar().showMessage("No recipient email configured", 3000)
                return
            
            # Simple email configuration (would need proper setup in a real application)
            # For security, these would typically be stored securely, not hardcoded
            sender = "crowdanalysis@example.com"
            password = ""  # Would need a real password/app password
            
            # Create message
            msg = MIMEMultipart()
            msg['From'] = sender
            msg['To'] = recipient
            msg['Subject'] = f"Crowd Analysis Alert: {subject}"
            
            # Add message body
            msg.attach(MIMEText(message, 'plain'))
            
            # Send email
            if password:  # Only try to send if configured
                server = smtplib.SMTP('smtp.example.com', 587)
                server.starttls()
                server.login(sender, password)
                server.send_message(msg)
                server.quit()
                
                self.statusBar().showMessage(f"Email alert sent to {recipient}", 3000)
            else:
                # Email not configured - just log
                print(f"Would send email: Subject: {subject}, Message: {message}")
                self.statusBar().showMessage("Email notification configured but not set up", 3000)
        except Exception as e:
            self.statusBar().showMessage(f"Failed to send email: {str(e)}", 3000)
    
    def show_desktop_notification(self, title, message):
        # Desktop notification implementation
        # This is platform-dependent and may need additional libraries
        
        # For Linux (requires notify-send)
        if sys.platform.startswith('linux'):
            try:
                os.system(f'notify-send "Crowd Analysis: {title}" "{message}"')
            except:
                pass
        # For Windows (requires win10toast)
        elif sys.platform.startswith('win'):
            # Placeholder - would require win10toast
            print(f"Windows Notification: {title} - {message}")
        # For macOS
        elif sys.platform.startswith('darwin'):
            try:
                os.system(f'osascript -e \'display notification "{message}" with title "Crowd Analysis: {title}"\'')
            except:
                pass
        
        # Fall back to status bar
        self.statusBar().showMessage(f"Alert: {title} - {message}", 5000)
    
    def toggle_recording(self):
        if not self.is_recording:
            self.start_recording()
        else:
            self.stop_recording()
    
    def start_recording(self):
        # Only allow recording when processing is active
        if not self.is_processing:
            self.statusBar().showMessage("Start video processing first", 3000)
            return
            
        # Setup video writer
        output_path = f"recordings/crowd_recording_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4"
        os.makedirs("recordings", exist_ok=True)
        
        # Get a frame to determine size
        if hasattr(self, 'video_thread') and hasattr(self.video_thread, 'last_frame'):
            h, w = self.video_thread.last_frame.shape[:2]
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            self.video_writer = cv2.VideoWriter(output_path, fourcc, 20.0, (w, h))
            
            # Connect signal
            self.video_thread.frame_update.connect(self.record_frame)
            
            self.is_recording = True
            self.record_button.setText("Stop Recording")
            self.recording_status.setText(f"Recording: {output_path}")
            self.recording_progress.setVisible(True)
            self.recording_progress.setValue(0)
            
            # Start recording timer
            self.recording_start_time = datetime.now()
            self.recording_timer = QTimer(self)
            self.recording_timer.timeout.connect(self.update_recording_progress)
            self.recording_timer.start(1000)  # Update every second
            
            self.statusBar().showMessage("Recording started", 3000)
        else:
            self.statusBar().showMessage("No video frame available", 3000)
    
    def stop_recording(self):
        if hasattr(self, 'video_writer'):
            # Disconnect signal
            try:
                self.video_thread.frame_update.disconnect(self.record_frame)
            except:
                pass
            
            # Release writer
            self.video_writer.release()
            del self.video_writer
            
            # Stop timer
            if hasattr(self, 'recording_timer'):
                self.recording_timer.stop()
            
            self.is_recording = False
            self.record_button.setText("Start Recording")
            self.recording_status.setText("Recording: Off")
            self.recording_progress.setVisible(False)
            self.statusBar().showMessage("Recording stopped", 3000)
    
    def record_frame(self, frame):
        if hasattr(self, 'video_writer'):
            # Convert RGB back to BGR for OpenCV
            frame_bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            self.video_writer.write(frame_bgr)
    
    def update_recording_progress(self):
        # Update recording progress (max 5 minutes)
        if hasattr(self, 'recording_start_time'):
            elapsed = (datetime.now() - self.recording_start_time).total_seconds()
            max_time = 5 * 60  # 5 minutes
            progress = min(int((elapsed / max_time) * 100), 100)
            self.recording_progress.setValue(progress)
            
            # Auto-stop if reached max time
            if progress >= 100:
                self.stop_recording()
    
    def update_status(self):
        # Periodically update dashboard status
        if self.is_processing:
            # Check if there are any alerts in the last 5 minutes
            self.cursor.execute(
                "SELECT COUNT(*) FROM alerts WHERE timestamp >= datetime('now', '-5 minutes')"
            )
            recent_alerts = self.cursor.fetchone()[0]
            
            if recent_alerts > 0:
                self.statusBar().showMessage(f"{recent_alerts} recent alerts detected", 3000)
    
    def closeEvent(self, event):
        # Clean up resources when closing
        if hasattr(self, 'video_thread') and self.video_thread.isRunning():
            self.video_thread.stop()
            self.video_thread.wait()
        
        # Stop recording if active
        if self.is_recording:
            self.stop_recording()
        
        # Close database connection
        if hasattr(self, 'conn'):
            self.conn.close()
        
        event.accept()


class VideoProcessingThread(QThread):
    # Signals for communication with the main thread
    frame_update = pyqtSignal(np.ndarray)
    stats_update = pyqtSignal(int, int, bool)  # crowd_count, violation_count, abnormal_activity
    alert_triggered = pyqtSignal(str, int, str)  # type, severity, description
    fps_update = pyqtSignal(float)  # fps
    
    def __init__(self, video_source, width=640, height=480, frame_skip=2, 
                social_distance=50, abnormal_energy=1866, abnormal_thresh=0.66):
        super().__init__()
        self.video_source = video_source
        self.running = False
        self.width = width
        self.height = height
        self.resolution = f"{width}x{height}"
        self.frame_skip = frame_skip
        
        # Initialize detector and tracker
        self.detector = YOLOv8Detector()
        
        # Initialize DeepSORT
        model_filename = 'model_data/mars-small128.pb'
        max_cosine_distance = 0.7
        nn_budget = None
        
        self.encoder = gdet.create_box_encoder(model_filename, batch_size=1)
        metric = nn_matching.NearestNeighborDistanceMetric("cosine", max_cosine_distance, nn_budget)
        self.tracker = Tracker(metric, max_age=30)
        
        # Configure detection parameters
        self.social_distance = social_distance
        self.abnormal_energy = abnormal_energy
        self.abnormal_thresh = abnormal_thresh
        self.abnormal_min_people = 5
        
        # Visualization mode
        self.view_mode = "Normal"
        
        # Heatmap data
        self.heatmap = None
        self.stationary_points = []
        
        # FPS calculation
        self.fps_frames = 0
        self.fps_time = 0
        self.fps = 0
    
    def run(self):
        # Start video processing
        self.running = True
        
        # Open video source
        cap = cv2.VideoCapture(self.video_source)
        
        if not cap.isOpened():
            self.alert_triggered.emit("System Error", 3, "Failed to open video source")
            return
        
        # Initialize variables
        frame_count = 0
        self.fps_time = datetime.now()
        
        # Initialize heatmap if needed
        ret, first_frame = cap.read()
        if ret:
            first_frame = cv2.resize(first_frame, (self.width, self.height))
            self.heatmap = np.zeros((first_frame.shape[0], first_frame.shape[1]), dtype=np.uint8)
        
        # Reset capture
        cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
        
        while self.running:
            ret, frame = cap.read()
            
            if not ret:
                # End of video or error
                if isinstance(self.video_source, str):
                    # For file, restart
                    cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                    continue
                else:
                    # For camera, error
                    self.alert_triggered.emit("System Error", 3, "Video source disconnected")
                    break
            
            frame_count += 1
            
            # Skip frames for performance
            if frame_count % self.frame_skip != 0:
                continue
            
            # Resize frame
            frame = cv2.resize(frame, (self.width, self.height))
            
            # Process the frame for crowd analysis
            processed_frame, stats = self.process_frame(frame, frame_count)
            
            # Convert BGR to RGB for Qt
            processed_frame_rgb = cv2.cvtColor(processed_frame, cv2.COLOR_BGR2RGB)
            
            # Store last frame
            self.last_frame = processed_frame_rgb.copy()
            
            # Emit signals with results
            self.frame_update.emit(processed_frame_rgb)
            
            crowd_count, violation_count, abnormal_activity = stats
            self.stats_update.emit(crowd_count, violation_count, abnormal_activity)
            
            # Check for alert conditions
            self.check_alerts(stats)
            
            # Calculate FPS
            self.fps_frames += 1
            current_time = datetime.now()
            elapsed = (current_time - self.fps_time).total_seconds()
            if elapsed >= 1.0:  # Update FPS every second
                self.fps = self.fps_frames / elapsed
                self.fps_update.emit(self.fps)
                self.fps_frames = 0
                self.fps_time = current_time
            
            # Control processing rate
            self.msleep(15)  # ~60 fps max
        
        # Clean up
        cap.release()
    
    def process_frame(self, frame, frame_count):
        # Detect humans
        boxes, confidences, centroids = self.detector.detect(frame)
        
        # Select visualization mode
        if self.view_mode == "Heatmap":
            return self.process_heatmap(frame, boxes, centroids, confidences, frame_count)
        elif self.view_mode == "Flow Tracking":
            return self.process_flow_tracking(frame, boxes, centroids, confidences, frame_count)
        else:  # Normal mode
            return self.process_normal_view(frame, boxes, centroids, confidences, frame_count)
    
    def process_normal_view(self, frame, boxes, centroids, confidences, frame_count):
        if len(boxes) > 0:
            # Convert to numpy arrays
            boxes_np = np.array(boxes)
            centroids_np = np.array(centroids)
            confidences_np = np.array(confidences)
            
            # Extract features for tracking
            features = np.array(self.encoder(frame, boxes_np))
            
            # Create detection objects
            detections = [Detection(bbox, score, centroid, feature) for bbox, score, centroid, feature in 
                        zip(boxes_np, confidences_np, centroids_np, features)]
            
            # Update tracker
            self.tracker.predict()
            expired = self.tracker.update(detections, frame_count)
            
            # Get confirmed tracks
            humans_detected = []
            for track in self.tracker.tracks:
                if not track.is_confirmed() or track.time_since_update > 5:
                    continue
                humans_detected.append(track)
            
            # Initialize stats
            violation_set = set()
            violate_count = np.zeros(len(humans_detected))
            abnormal_individual = []
            
            # Process each detection
            for i, track in enumerate(humans_detected):
                # Get object bounding box
                [x, y, w, h] = list(map(int, track.to_tlbr().tolist()))
                # Get object centroid
                [cx, cy] = list(map(int, track.positions[-1]))
                
                # Check for social distance violation
                if len(humans_detected) >= 2:
                    for j, track_2 in enumerate(humans_detected[i+1:], start=i+1):
                        [cx_2, cy_2] = list(map(int, track_2.positions[-1]))
                        distance = np.sqrt((cx - cx_2)**2 + (cy - cy_2)**2)
                        
                        if distance < self.social_distance:
                            violation_set.add(i)
                            violate_count[i] += 1
                            violation_set.add(j)
                            violate_count[j] += 1
                            
                            # Draw line between violating individuals
                            cv2.line(frame, (cx, cy), (cx_2, cy_2), (0, 0, 255), 1)
                
                # Check for abnormal movement energy
                if len(track.positions) >= 2:
                    prev_pos = track.positions[-2]
                    curr_pos = track.positions[-1]
                    
                    # Calculate energy
                    energy = kinetic_energy(curr_pos, prev_pos, 1.0)
                    
                    if energy > self.abnormal_energy:
                        abnormal_individual.append(track.track_id)
                
                # Update stationary points for heatmap
                if len(track.positions) >= 3:
                    # Check if person is stationary
                    positions = track.positions[-3:]
                    min_x = min(p[0] for p in positions)
                    max_x = max(p[0] for p in positions)
                    min_y = min(p[1] for p in positions)
                    max_y = max(p[1] for p in positions)
                    
                    # If movement is less than threshold, consider stationary
                    if (max_x - min_x < 10) and (max_y - min_y < 10):
                        self.stationary_points.append((cx, cy))
                        # Update heatmap
                        cv2.circle(self.heatmap, (cx, cy), 5, 255, -1)
                
                # Draw bounding boxes
                if i in violation_set:
                    cv2.rectangle(frame, (x, y), (w, h), (0, 165, 255), 2)  # Orange
                    if len(track.positions) >= 2:
                        # Draw movement trail for violations
                        for pos_idx in range(1, min(len(track.positions), 10)):
                            prev_pos = track.positions[-pos_idx-1]
                            curr_pos = track.positions[-pos_idx]
                            cv2.line(frame, tuple(map(int, prev_pos)), tuple(map(int, curr_pos)), 
                                    (0, 165, 255), 1)
                else:
                    cv2.rectangle(frame, (x, y), (w, h), (0, 255, 0), 2)  # Green
                
                # Draw ID
                cv2.putText(frame, str(track.track_id), (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
            
            # Determine if abnormal activity is occurring
            abnormal_activity = False
            if len(humans_detected) > self.abnormal_min_people:
                if len(abnormal_individual) / len(humans_detected) > self.abnormal_thresh:
                    abnormal_activity = True
                    
                    # Highlight individuals with abnormal movement
                    for track in humans_detected:
                        if track.track_id in abnormal_individual:
                            [x, y, w, h] = list(map(int, track.to_tlbr().tolist()))
                            cv2.rectangle(frame, (x, y), (w, h), (255, 0, 0), 3)  # Blue, thicker
            
            # Add stats to frame
            cv2.putText(frame, f"Count: {len(humans_detected)}", (10, 30), 
                      cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
            
            cv2.putText(frame, f"Violations: {len(violation_set)}", (10, 60), 
                      cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 255, 255), 2)
            
            if abnormal_activity:
                cv2.putText(frame, "ABNORMAL ACTIVITY", (frame.shape[1]//2 - 100, 50), 
                          cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 3)
            
            return frame, (len(humans_detected), len(violation_set), abnormal_activity)
        
        # No detections
        return frame, (0, 0, False)
    
    def process_heatmap(self, frame, boxes, centroids, confidences, frame_count):
        # First process normally to update tracking
        normal_frame, stats = self.process_normal_view(frame, boxes, centroids, confidences, frame_count)
        
        # Apply heatmap visualization
        if self.heatmap is not None:
            # Apply colormap to heatmap
            colored_heatmap = cv2.applyColorMap(self.heatmap, cv2.COLORMAP_JET)
            
            # Blend with original frame
            alpha = 0.7
            beta = 0.3
            gamma = 0
            heatmap_overlay = cv2.addWeighted(normal_frame, beta, colored_heatmap, alpha, gamma)
            
            # Add explanation text
            cv2.putText(heatmap_overlay, "Heatmap Mode: Shows stationary points", (10, frame.shape[0] - 20),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
            
            return heatmap_overlay, stats
        
        return normal_frame, stats
    
    def process_flow_tracking(self, frame, boxes, centroids, confidences, frame_count):
        # Create a copy for flow visualization
        flow_frame = frame.copy()
        
        # First process normally to update tracking
        normal_frame, stats = self.process_normal_view(frame, boxes, centroids, confidences, frame_count)
        
        # Now draw flow paths for each tracked object
        # Create a transparent overlay for flow paths
        overlay = np.zeros_like(flow_frame)
        
        for track in self.tracker.tracks:
            if not track.is_confirmed() or track.time_since_update > 5:
                continue
                
            # Get the track's positions history
            positions = track.positions
            
            if len(positions) > 1:
                # Draw trajectory - use a rainbow color pattern based on track ID
                track_id = track.track_id
                color_id = track_id % 6  # 6 different colors
                
                colors = [
                    (255, 0, 0),    # Red
                    (0, 255, 0),    # Green
                    (0, 0, 255),    # Blue
                    (255, 255, 0),  # Yellow
                    (255, 0, 255),  # Magenta
                    (0, 255, 255)   # Cyan
                ]
                
                color = colors[color_id]
                
                # Draw path with thicker lines
                for i in range(1, len(positions)):
                    p1 = tuple(map(int, positions[i-1]))
                    p2 = tuple(map(int, positions[i]))
                    cv2.line(overlay, p1, p2, color, 2)
                    
                # Draw start point (circle)
                cv2.circle(overlay, tuple(map(int, positions[0])), 5, color, -1)
                
                # Draw current point
                current_pos = tuple(map(int, positions[-1]))
                cv2.circle(overlay, current_pos, 7, color, -1)
                
                # Draw ID at current position
                cv2.putText(overlay, str(track.track_id), 
                           (current_pos[0] + 10, current_pos[1] + 10), 
                           cv2.FONT_HERSHEY_SIMPLEX, 0.8, color, 2)
        
        # Blend overlay with frame
        flow_visualization = cv2.addWeighted(normal_frame, 0.7, overlay, 0.7, 0)
        
        # Add explanation text
        cv2.putText(flow_visualization, "Flow Tracking Mode: Shows movement patterns", 
                  (10, flow_frame.shape[0] - 20),
                  cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
        
        return flow_visualization, stats
    
    def check_alerts(self, stats):
        crowd_count, violation_count, abnormal_activity = stats
        
        # Check for crowding
        if crowd_count > 15:
            severity = 2 if crowd_count > 25 else 1
            self.alert_triggered.emit(
                "High Crowd Density", 
                severity, 
                f"Detected {crowd_count} people in the monitored area"
            )
        
        # Check for social distance violations
        if violation_count > 5:
            severity = 2 if violation_count > 10 else 1
            self.alert_triggered.emit(
                "Social Distance Violations", 
                severity, 
                f"Detected {violation_count} social distance violations"
            )
        
        # Check for abnormal activity
        if abnormal_activity:
            self.alert_triggered.emit(
                "Abnormal Crowd Activity", 
                3,  # Critical severity
                "Unusual movement patterns detected in the crowd"
            )
    
    def stop(self):
        # Stop processing
        self.running = False